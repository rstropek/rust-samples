{
  "0010_hello_world": {
    "prefix": "rs",
    "body": [
      "use axum::{routing::get, Router};",
      "",
      "// Note that Axum uses tokio as its runtime, so we need to use the #[tokio::main]",
      "#[tokio::main]",
      "async fn main() {",
      "    // Learn more about routing at https://docs.rs/axum/latest/axum/index.html#routing",
      "    let app = Router::new()",
      "        .route(\"/\", get(|| async { \"Hello, World!\" }));",
      "",
      "    // Run the server on port 3000. In practice, make settings like that",
      "    // configurable (e.g. using clap).",
      "    axum::Server::bind(&\"0.0.0.0:3000\".parse().unwrap())",
      "        .serve(app.into_make_service())",
      "        .await",
      "        .unwrap();",
      "}"
    ],
    "description": ""
  },
  "0020_handler_function": {
    "prefix": "rs",
    "body": [
      "// Let's move the code of the handler into a dedicated function.",
      "// Don't forget to change the router so that it points to the fuction.",
      "async fn hello_world() -> &'static str {",
	  "	   // A handler is a function that takes 0..n extractors (see later)",
	  "    // and returns something that implements IntoResponse.",
      "    \"Hello, World!\"",
      "}"
    ]
  },
  "0030_different_verbs": {
    "prefix": "rs",
    "body": [
      ".route(\"/\", get(hello_world).post(|| async { \"Hello, World ✉️!\"}))"
    ]
  },
  "0040_router_builder": {
    "prefix": "rs",
    "body": [
      "fn pingpong() -> Router {",
      "    Router::new().route(\"/ping\", get(|| async { \"pong\" }))",
      "}",
      "",
      "fn kingkong() -> Router {",
      "    async fn king() -> &'static str {",
      "        \"Kong\"",
      "    }",
      "",
      "    Router::new().route(\"/king\", get(king))",
      "}"
    ]
  },
  "0050_merging_nesting": {
    "prefix": "rs",
    "body": [
      "// Let's add additional routes. Note that we can structure complex",
      "// routing hierarchies using methods like merge and nest.",
      ".merge(pingpong())",
      ".nest(\"/kingkong\", kingkong());"
    ]
  },
  "0060_path_extractor": {
    "prefix": "rs",
    "body": [
      "// Path is an \"Extractor\". Extractors are used to extract data from the request.",
      "// .route(\"/greet/:name\", get(greet_path))",
      "async fn greet_path(Path(name): Path<String>) -> String {",
      "    format!(\"Hello, {}!\", name)",
      "}"
    ]
  },
  "0070_query_extractor": {
    "prefix": "rs",
    "body": [
      "#[derive(Serialize, Deserialize, Debug, Clone, Default)]",
      "struct QueryParameters {",
      "    salutation: Option<String>,",
      "    name: Option<String>,",
      "}",
      "",
      "// Query is also an \"Extractor\".",
      "// .route(\"/greet\", get(greet_query))",
      "async fn greet_query(Query(params): Query<QueryParameters>) -> String {",
      "    let salutation = params.salutation.unwrap_or_else(|| \"Hello\".to_string());",
      "    let name = params.name.unwrap_or_else(|| \"World\".to_string());",
      "    format!(\"{}, {}!\", salutation, name)",
      "}"
    ]
  },
  "0080_json_extractor": {
    "prefix": "rs",
    "body": [
      "// Json is the third commonly used extractor.",
      "// .route(\"/greet\", get(greet_query).post(greet_body))",
      "async fn greet_body(Json(params): Json<QueryParameters>) -> String {",
      "    let salutation = params.salutation.unwrap_or_else(|| \"Hello\".to_string());",
      "    let name = params.name.unwrap_or_else(|| \"World\".to_string());",
      "    format!(\"{}, {}!\", salutation, name)",
      "}",
      "",
      "// NOTE: You can learn all details about extractor at",
      "// https://docs.rs/axum/latest/axum/extract/index.html#defining-custom-extractors"
    ]
  },
  "0090_into_response": {
	"prefix": "rs",
	"body": [
	  "#[derive(Serialize)]",
	  "struct LookupResult {",
	  "    number: i32,",
	  "    found: bool,",
	  "}",
	  "",
	  "// A lot of types implement IntoResponse, including tuples.",
	  "// Read more at https://docs.rs/axum/latest/axum/response/trait.IntoResponse.html",
	  "// .route(\"/lookup\", get(look_it_up))",
	  "async fn look_it_up(Path(number): Path<i32>) -> impl IntoResponse {",
	  "    // Let's say that only odd numbers are \"found\"",
	  "    match number % 2 {",
	  "        1 => (StatusCode::OK, Json(LookupResult { number, found: true })),",
	  "        _ => (StatusCode::NOT_FOUND, Json(LookupResult { number, found: false })),",
	  "    }",
	  "}"
	]
  }
}
